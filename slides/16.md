# Concurrency - Live Examples

[Concurrent Examples @ github](https://github.com/athenaeum-brew/concurrent-examples)

---

# Concurrency - Live Examples 1


<small>Synchronous code</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example00Sync {
    public static void main(String[] args) {
        System.out.println("Task 1");
        System.out.println("Task  2");
        System.out.println("Task   3");
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example00Sync.java
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

--

<small>Asynchronous code</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example01Async {
    public static void main(String[] args) {
        new Thread(() -> System.out.println("Task 1")).start();
        new Thread(() -> System.out.println("Task  2")).start();
        new Thread(() -> System.out.println("Task   3")).start();
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example01Async.java
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

--

<small>Asynchronous code with loop</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example02AsyncLoop {
    public static void main(String[] args) {
        int c = 3;
        while (c-- > 0) {
            new Thread(() -> System.out.println("Task 1")).start();
            new Thread(() -> System.out.println("Task  2")).start();
            new Thread(() -> System.out.println("Task   3")).start();
        }
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example02AsyncLoop.java
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

---

# Concurrency - Live Examples 1

<small>Asynchronous code with sleep</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example03AsyncLoopSleep {

    static void syncTask(final int n) {
        randomFreeze(); // wait for some random duration
        System.out.println(String.format("Task %" + n + "d", n));
    }

    static void asyncTask(final int n) {
        new Thread(() -> syncTask(n)).start();
    }

    public static void main(String[] args) {
        int c = 3;
        while (c-- > 0) {
            asyncTask(1);
            asyncTask(2);
            asyncTask(3);
        }
    }

    static final Random r = new Random(new Date().getTime());

    static void randomFreeze() {
        try {
            Thread.sleep(r.nextLong(0, 10));
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example03AsyncLoopSleep.java
Task  2
Task   3
Task  2
Task   3
Task 1
Task   3
Task 1
Task 1
Task  2
</code></pre>

<!-- img src="/images/relief.jpg" alt="relief" -->

</div>

</div>

--

FYI, [an asyncronous version of the same code](https://github.com/athenaeum-brew/concurrent-examples/blob/main/Example04AsyncWithLatches.java) that produce an ordered output, using [latches](https://www.baeldung.com/java-countdown-latch).

---

# Concurrency - Lesson

Lesson learned: 

**An (incorrect) asynchronous, parallel, concurrent, or multithreaded program may produce the expected results for a loooong time before crashing unexpectedly.**

---

# Concurrency - Testing

<!-- Although testing is explicitly out of the scope of this course, I cannot help but briefly mention some guidelines for testing asynchronous, parallel, concurrent, or multithreaded programs. -->

<small>

1. **Unit Testing**: Use mocking frameworks (like [Mockito](https://site.mockito.org/)) to simulate asynchronous behavior and test individual components in isolation.

--

1. **Thread Contention Testing**: Use tools like [Apache JMeter](https://jmeter.apache.org/) or [Gatling](https://gatling.io/) to simulate high load and thread contention.

--

1. **Race Condition Detection**: Use static analysis tools like [SonarQube](https://www.sonarsource.com/products/sonarqube) to detect potential race conditions in your code.
Employ dynamic analysis tools like [ThreadSanitizer](https://openjdk.org/jeps/8208520) (work in progress) or tools integrated in IDEs (like IntelliJ IDEAâ€™s concurrency analysis features).

--

1. **Code Reviews**: Conduct thorough code reviews with a focus on concurrency issues.
Have multiple team members review the code to identify potential pitfalls in thread management and synchronization.

--

1. **Logging and Monitoring**: Implement extensive logging to trace the behavior of threads and asynchronous operations.
Use monitoring tools to observe the system in real-time and post-mortem analysis to identify the causes of crashes.

--

1. **Use of Concurrent Collections and Utilities**: Prefer using thread-safe collections and utilities provided by the Java java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, and ExecutorService.

</small>

---

# Concurrency - Live Examples 2

Introducing [TheBumper](https://github.com/athenaeum-brew/concurrent-examples/blob/main/TheBumper.java) class.

```java
public final class TheBumper {
    private final String title = "\nA programmer had a problem. He thought to himself, \"I know, I'll solve it with threads!\".\n";
    private final String[] array = new String[] { "Now,", "he", "has", "two", "problems." };
    private int count = 0;

    public final String next() {
        return array[increment()];
    }

    private final int increment() {
        return count++;
    }

    public final int length() {
        return array.length;
    }

    public final String title() {
        return title;
    }
}
```

---

# Concurrency - Live Examples 2

Synchronous Bumper

```java
public class Example10BumperSync {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            System.out.println(bumper.next());
        }
    }
}
```

Output:

```bash
% java Example10BumperSync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[main] Now, 
[main] he 
[main] has 
[main] two 
[main] problems. 
```

---

# Concurrency - Live Examples 2

Asynchronous Bumper

```java
public class Example11BumperAsync {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                System.out.println(bumper.next());
            });
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
            ; // Wait for all threads to finish
        }
    }
}
```

Output:

```bash
% java Example11BumperAsync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-2] he 
[pool-1-thread-1] Now, 
[pool-1-thread-5] problems. 
[pool-1-thread-4] two 
[pool-1-thread-3] has 
```

---

# Concurrency

The **synchronized** Keyword in Java

<small>

*Ensures that only one thread can access a critical section of code at a time.*

--

Applied to methods or code blocks. 

</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public synchronized void synchronizedMethod() {
    // Critical section of code
    // Only one thread can execute this method at a time
}</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-java">// Object used for synchronization
private static final Object lock = new Object(); 
public void doSomethingSynchronized() {
    synchronized (lock) {
        // Critical section of code
        // Only one thread can execute this block at a time
    }
}
</code></pre>
</div>
</div>

<small>

--

**Advantages**:
Simplifies multithreading by handling synchronization internally.
Prevents concurrent modification of shared resources, which is a common cause of race conditions.

--

**Disadvantages**:
Can cause performance overhead due to locking.
May lead to potential deadlocks if not used cautiously.

--

**Best Practices**:
Use synchronized blocks for finer-grained control.
Consider alternatives like java.util.concurrent for more advanced synchronization needs.

</small>

---

# Concurrency - Live Examples 2

Synchronized Asynchronous Bumper

```java
public class Example12BumperSynchronized {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                synchronized (bumper) {
                    System.out.println(bumper.next());
                }
            });
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
            ; // Wait for all threads to finish
        }
    }
}
```

Output:

```bash
% java Example12BumperSynchronized.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-1] Now, 
[pool-1-thread-5] he 
[pool-1-thread-4] has 
[pool-1-thread-3] two 
[pool-1-thread-2] problems. 
```

---

# Concurrency

The **volatile** Keyword in Java

*Ensures that changes made to a variable are immediately visible to other threads and prevents certain compiler optimizations that might otherwise reorder or optimize away accesses to that variable.*

---

# Concurrency

<small>

**CPU Caching**:
Modern CPUs use caches to store frequently accessed data for faster access.
When a variable is accessed, the CPU may load it into its cache for quicker retrieval.
Multiple cores in a CPU might have separate caches, leading to each core potentially having its own copy of data.

**Compiler Optimization**:
Compilers may optimize code to improve performance.
Optimization techniques may include reordering instructions or storing variables in CPU registers.
The compiler might optimize away unnecessary reads or writes to variables if it believes they are not needed based on its analysis of the code.

**Implications**:
- *Visibility of Changes*: Changes made to variables by one thread may not immediately be visible to other threads due to caching.
- *Reordering*: Compiler optimizations may reorder instructions, potentially changing the order of operations as perceived by other threads.

**Mitigation**:
- Volatile Keyword: Use volatile keyword in Java to ensure visibility of changes across threads and prevent compiler optimizations.
- Synchronization: Use synchronization mechanisms like locks or synchronized blocks to enforce memory consistency and order of execution.

</small>

---

# Concurrency - Live Examples 3

The **volatile** Keyword in Java

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example20Volatile {
    static class Toggler {
        private /* volatile */ boolean flag = false;
        public void toggleFlag() {
            flag = !flag;
        }
        public boolean isFlag() {
            return flag;
        }
    }
    public static void main(String[] args) {
        Toggler toggler = new Toggler();
        // Thread 1: Modifies the flag
        new Thread(() -> {
            TheUtils.randomFreeze(100);
            toggler.toggleFlag();
            System.out.println("Flag set to true.");
        }).start();
        // Thread 2: Reads the flag
        new Thread(() -> {
            while (!toggler.isFlag()) {
                // Busy wait until flag becomes true
            }
            System.out.println("Flag is now true.");
        }).start();
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<small>Without volatile:</small>

<pre><code class="language-bash">% java Example20Volatile.java

Flag set to true.
^C
</code></pre>

<small>With volatile:</small>

<pre><code class="language-bash">% java Example20Volatile.java

Flag is now true.
Flag set to true.
</code></pre>

</div>
</div>

