# Concurrency - Live Examples

All sources here: 

[https://github.com/athenaeum-brew/concurrent-examples](https://github.com/athenaeum-brew/concurrent-examples)

---

# Concurrency - Live Examples 1


<small>Synchronous code</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example00Sync {
    public static void main(String[] args) {
        System.out.println("Task 1");
        System.out.println("Task  2");
        System.out.println("Task   3");
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-bash">% java Example00Sync.java
Task 1
Task  2
Task   3
</code></pre>
</div>
</div>

--

<small>Asynchronous code</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example01Async {
    public static void main(String[] args) {
        new Thread(() -> System.out.println("Task 1")).start();
        new Thread(() -> System.out.println("Task  2")).start();
        new Thread(() -> System.out.println("Task   3")).start();
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-bash">% java Example01Async.java
Task 1
Task  2
Task   3
</code></pre>
</div>
</div>

--

<small>Asynchronous code with loop</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example02AsyncLoop {
    public static void main(String[] args) {
        int c = 3;
        while (c-- > 0) {
            new Thread(() -> System.out.println("Task 1")).start();
            new Thread(() -> System.out.println("Task  2")).start();
            new Thread(() -> System.out.println("Task   3")).start();
        }
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-bash">% java Example02AsyncLoop.java
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
</code></pre>
</div>
</div>

---

# Concurrency - Live Examples 1

<small>Asynchronous code with sleep</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example03AsyncLoopSleep {

    static void task(final int n) {
        randomFreeze(); // wait for some random duration
        System.out.println(String.format("Task %" + n + "d", n));
    }

    static void asyncTask(final int n) {
        new Thread(() -> task(n)).start();
    }

    public static void main(String[] args) {
        IntStream.range(0, 3).forEach(c -> {
            asyncTask(1);
            asyncTask(2);
            asyncTask(3);
        }
    }

    static final Random r = new Random(new Date().getTime());

    static void randomFreeze() {
        try {
            Thread.sleep(r.nextLong(0, 10));
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-bash">% java Example03AsyncLoopSleep.java
Task  2
Task   3
Task  2
Task   3
Task 1
Task   3
Task 1
Task 1
Task  2
</code></pre>
<!-- img src="/images/relief.jpg" alt="relief" -->
</div>
</div>

--

<small>
(
BTW, & FYI, here is [an asyncronous version](https://github.com/athenaeum-brew/concurrent-examples/blob/main/Example04AsyncWithLatches.java) that produce an ordered output, using [latches](https://www.baeldung.com/java-countdown-latch)
)
</small>

---

# Concurrency - Lesson

Lesson learned: 

**An (incorrect) asynchronous, parallel, concurrent, or multithreaded program may produce the expected results for a loooong time before crashing unexpectedly.**

---

# Concurrency - Testing

<!-- Although testing is explicitly out of the scope of this course, I cannot help but briefly mention some guidelines for testing asynchronous, parallel, concurrent, or multithreaded programs. -->

<small>

1. **Unit Testing**: Use mocking frameworks (like [Mockito](https://site.mockito.org/)) to simulate asynchronous behavior and test individual components in isolation.

--

1. **Thread Contention Testing**: Use tools like [Apache JMeter](https://jmeter.apache.org/) or [Gatling](https://gatling.io/) to simulate high load and thread contention.

--

1. **Race Condition Detection**: Use static analysis tools like [SonarQube](https://www.sonarsource.com/products/sonarqube) to detect potential race conditions in your code.
Employ dynamic analysis tools like [ThreadSanitizer](https://openjdk.org/jeps/8208520) (work in progress) or tools integrated in IDEs (like IntelliJ IDEAâ€™s concurrency analysis features).

--

1. **Code Reviews**: Conduct thorough code reviews with a focus on concurrency issues.
Have multiple team members review the code to identify potential pitfalls in thread management and synchronization.

--

1. **Logging and Monitoring**: Implement extensive logging to trace the behavior of threads and asynchronous operations.
Use monitoring tools to observe the system in real-time and post-mortem analysis to identify the causes of crashes.

--

1. **Use of Concurrent Collections and Utilities**: Prefer using thread-safe collections and utilities provided by the Java java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, and ExecutorService.

</small>

---

# Concurrency - Live Examples 2

Introducing [TheBumper](https://github.com/athenaeum-brew/concurrent-examples/blob/main/TheBumper.java) class.

```java
public final class TheBumper {
    private final String title = "\nA programmer had a problem. He thought to himself, \"I know, I'll solve it with threads!\".\n";
    private final String[] array = new String[] { "Now,", "he", "has", "two", "problems." };
    private int count = 0;

    public final String next() {
        return array[increment()];
    }

    private final int increment() {
        return count++;
    }

    public final int length() {
        return array.length;
    }

    public final String title() {
        return title;
    }
}
```

---

# Concurrency - Live Examples 2

Synchronous Bumper

```java
public class Example10BumperSync {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            System.out.println(bumper.next());
        }
    }
}
```

Output:

```bash
% java Example10BumperSync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[main] Now, 
[main] he 
[main] has 
[main] two 
[main] problems. 

```

---

# Concurrency - Live Examples 2

Asynchronous Bumper

```java
public class Example11BumperAsync throws InterruptedException {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                System.out.println(bumper.next());
            });
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
    }
}
```

Output:

```bash
% java Example11BumperAsync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-2] he 
[pool-1-thread-1] Now, 
[pool-1-thread-5] problems. 
[pool-1-thread-4] two 
[pool-1-thread-3] has 

```

---

# Concurrency

The **synchronized** Keyword in Java

<small>

*Ensures that only one thread can access a critical section of code at a time.*

--

Applied to methods or code blocks. 

</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public synchronized void synchronizedMethod() {
    // Critical section of code
    // Only one thread can execute this method at a time
}</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-java">// Object used for synchronization
private static final Object lock = new Object(); 
public void doSomethingSynchronized() {
    synchronized (lock) {
        // Critical section of code
        // Only one thread can execute this block at a time
    }
}
</code></pre>
</div>
</div>

<small>

--

**Advantages**:
Simplifies multithreading by handling synchronization internally.
Prevents concurrent modification of shared resources, which is a common cause of race conditions.

--

**Disadvantages**:
Can cause performance overhead due to locking.
May lead to potential deadlocks if not used cautiously.

--

**Best Practices**:
Use synchronized blocks for finer-grained control.
Consider alternatives like java.util.concurrent for more advanced synchronization needs.

</small>

---

# Concurrency - Live Examples 2

Synchronized Asynchronous Bumper

```java
public class Example12BumperSynchronized throws InterruptedException {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                synchronized (bumper) {
                    System.out.println(bumper.next());
                }
            });
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
    }
}
```

Output:

```bash
% java Example12BumperSynchronized.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-1] Now, 
[pool-1-thread-5] he 
[pool-1-thread-4] has 
[pool-1-thread-3] two 
[pool-1-thread-2] problems. 

```

---

# Concurrency

The **volatile** Keyword in Java

*Ensures that changes made to a variable are immediately visible to other threads and prevents certain compiler optimizations that might otherwise reorder or optimize away accesses to that variable.*

---

# Concurrency

<small>

**CPU Caching**:
Modern CPUs use caches to store frequently accessed data for faster access.
When a variable is accessed, the CPU may load it into its cache for quicker retrieval.
Multiple cores in a CPU might have separate caches, leading to each core potentially having its own copy of data.

**Compiler Optimization**:
Compilers may optimize code to improve performance.
Optimization techniques may include reordering instructions or storing variables in CPU registers.
The compiler might optimize away unnecessary reads or writes to variables if it believes they are not needed based on its analysis of the code.

**Implications**:
- *Visibility of Changes*: Changes made to variables by one thread may not immediately be visible to other threads due to caching.
- *Reordering*: Compiler optimizations may reorder instructions, potentially changing the order of operations as perceived by other threads.

**Mitigation**:
- Volatile Keyword: Use volatile keyword in Java to ensure visibility of changes across threads and prevent compiler optimizations.
- Synchronization: Use synchronization mechanisms like locks or synchronized blocks to enforce memory consistency and order of execution.

</small>

---

# Concurrency - Live Examples 3

The **volatile** Keyword in Java

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example20Volatile {
    static class Toggler {
        private /* volatile */ boolean flag = false;
        public void toggleFlag() {
            flag = !flag;
        }
        public boolean isFlag() {
            return flag;
        }
    }
    public static void main(String[] args) {
        Toggler toggler = new Toggler();
        // Thread 1: Modifies the flag
        new Thread(() -> {
            TheUtils.randomFreeze(100);
            toggler.toggleFlag();
            System.out.println("Flag set to true.");
        }).start();
        // Thread 2: Reads the flag
        new Thread(() -> {
            while (!toggler.isFlag()) {
                // Busy wait until flag becomes true
            }
            System.out.println("Flag is now true.");
        }).start();
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<small>Without volatile:</small>

<pre><code class="language-bash">% java Example20Volatile.java

Flag set to true.
^C
</code></pre>

<small>With volatile:</small>

<pre><code class="language-bash">% java Example20Volatile.java

Flag is now true.
Flag set to true.
</code></pre>
</div>
</div>

---

# Concurrency - Live Examples 4

Atomic classes

--

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example30Atomic {

    static class Holder {
        int i = 0;
        AtomicInteger atomicInteger = new AtomicInteger(0);
    }

    public static void main(String[] args) throws InterruptedException {
        Holder holder = new Holder();
        int cpus = Runtime.getRuntime().availableProcessors();

        ExecutorService service = Executors.newFixedThreadPool(cpus);

        IntStream.range(0, 1_000_000)
                .forEach(c -> service.submit(() -> {
                    holder.i++;
                    holder.atomicInteger.incrementAndGet();
                }));

        service.shutdown();
        service.awaitTermination(10, TimeUnit.SECONDS);

        System.out.println(String.format("\n%13s: %7d\n%13s: %7d\n",
                "int",
                holder.i,
                holder.atomicInteger.getClass().getSimpleName(),
                holder.atomicInteger.get()));
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example30Atomic.java

          int:  998541
AtomicInteger: 1000000

</code></pre>

</div>
</div>

---

# Concurrency - Live Examples 5

Lock, ReentrantLock, and Fairness.

--

**Lock**: An interface for thread synchronization in java.util.concurrent.locks.
- Flexibility: More control than synchronized.
- Key Methods: lock(), unlock(), tryLock(), newCondition().

--

**ReentrantLock**: A concrete implementation of the Lock interface. Allows the same thread to lock multiple times.
- Methods: lock(), unlock(), tryLock(), lockInterruptibly().
- Performance: Generally faster and more scalable than synchronized.

--

**Fairness**: Ensures locks are granted in request order (FIFO).
- ReentrantLock Fair Mode: new ReentrantLock(true) for fairness.
- Trade-offs: Fair locks reduce starvation but may lower throughput.

---

# Concurrency - Live Examples 5

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example40ReentrantLock {
    static class Freezer {
        void freeze(Lock lock) {
            try {
                lock.lock();
                TheUtils.println("<");
                TheUtils.randomFreeze(100);
                TheUtils.println(" >");
            } finally {
                lock.unlock();
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        final Lock lock = new ReentrantLock(false); // <--- fairness !
        ExecutorService executor = Executors.newFixedThreadPool(6);
        IntStream.range(0, 6).forEach(t -> {
            final Freezer f = new Freezer();
            executor.execute(() -> {
                IntStream.range(0, 3).forEach(e -> {
                    f.freeze(lock);
                });
            });
        });
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        System.out.println("");
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example40ReentrantLock.java
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
</code></pre>

</div>
</div>

---

# Concurrency - Live Examples 5

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public class Example40ReentrantLock {
    static class Freezer {
        void freeze(Lock lock) {
            try {
                lock.lock();
                TheUtils.println("<");
                TheUtils.randomFreeze(100);
                TheUtils.println(" >");
            } finally {
                lock.unlock();
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        final Lock lock = new ReentrantLock(true); // <--- fairness !
        ExecutorService executor = Executors.newFixedThreadPool(6);
        IntStream.range(0, 6).forEach(t -> {
            final Freezer f = new Freezer();
            executor.execute(() -> {
                IntStream.range(0, 3).forEach(e -> {
                    f.freeze(lock);
                });
            });
        });
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        System.out.println("");
    }
}
</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example40ReentrantLock.java
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
[pool-1-thread-1]  < 
[pool-1-thread-1]   > 
[pool-1-thread-2]  < 
[pool-1-thread-2]   > 
[pool-1-thread-4]  < 
[pool-1-thread-4]   > 
[pool-1-thread-3]  < 
[pool-1-thread-3]   > 
[pool-1-thread-5]  < 
[pool-1-thread-5]   > 
[pool-1-thread-6]  < 
[pool-1-thread-6]   > 
</code></pre>

</div>
</div>

---

# Concurrency - Summary

![Java Concurrency in Practice](/images/BrianGoetz.jpg)

---

# Concurrency - Summary
<small>
- *It's the mutable state, stupid.*<br>
All concurrency issues boil down to coordinating access to mutable state. The less mutable state, the easier it is to ensure thread safety.
--

- *Make fields final unless they need to be mutable.*
--

- *Immutable objects are automatically thread-safe.*<br>
Immutable objects simplify concurrent programming tremendously.
They are simpler and safer, and can be shared freely without locking or defensive copying.
--

- *Encapsulation makes it practical to manage the complexity.*<br>
You could write a thread-safe program with all data stored in global variables, but why would you want to? Encapsulating data within objects makes it easier to preserve their invariants; encapsulating synchronization within objects makes it easier to comply with their synchronization policy.
--

- *Guard each mutable variable with a lock.*
--

- *Guard all variables in an invariant with the same lock.*
--

- *Hold locks for the duration of compound actions.*
--

- *A program that accesses a mutable variable from multiple threads without synchronization is a broken program.*
--

- *Don't rely on clever reasoning about why you don't need to synchronize.*
--

- *Include thread safety in the design process or explicitly document that your class is not thread-safe.*
--

- *Document your synchronization policy.*
</small>
