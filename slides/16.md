# Concurrency - Live Examples

[Concurrent Examples @ github](https://github.com/athenaeum-brew/concurrent-examples)

---

# Concurrency - Live Examples 1


<small>Synchronous code</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example00Sync {
    public static void main(String[] args) {
        System.out.println("Task 1");
        System.out.println("Task  2");
        System.out.println("Task   3");
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example00Sync.java
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

--

<small>Asynchronous code</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example01Async {
    public static void main(String[] args) {
        new Thread(() -> System.out.println("Task 1")).start();
        new Thread(() -> System.out.println("Task  2")).start();
        new Thread(() -> System.out.println("Task   3")).start();
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example01Async.java
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

--

<small>Asynchronous code with loop</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example02AsyncLoop {
    public static void main(String[] args) {
        int c = 3;
        while (c-- > 0) {
            new Thread(() -> System.out.println("Task 1")).start();
            new Thread(() -> System.out.println("Task  2")).start();
            new Thread(() -> System.out.println("Task   3")).start();
        }
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example02AsyncLoop.java
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
Task 1
Task  2
Task   3
</code></pre>

</div>

</div>

---

# Concurrency - Live Examples 1

<small>Asynchronous code with sleep</small>

<div style="display: flex;">

<div style="flex: 1; margin-right:1rem;">

<pre><code class="language-java">public class Example03AsyncLoopSleep {

    static void syncTask(final int n) {
        randomFreeze(); // wait for some random duration
        System.out.println(String.format("Task %" + n + "d", n));
    }

    static void asyncTask(final int n) {
        new Thread(() -> syncTask(n)).start();
    }

    public static void main(String[] args) {
        int c = 3;
        while (c-- > 0) {
            asyncTask(1);
            asyncTask(2);
            asyncTask(3);
        }
    }

    static final Random r = new Random(new Date().getTime());

    static void randomFreeze() {
        try {
            Thread.sleep(r.nextLong(0, 10));
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>

</div>

<div style="flex: 1; margin-left:1rem;">

<pre><code class="language-bash">% java Example03AsyncLoopSleep.java
Task  2
Task   3
Task  2
Task   3
Task 1
Task   3
Task 1
Task 1
Task  2
</code></pre>

<!-- img src="/images/relief.jpg" alt="relief" -->

</div>

</div>

--

FYI, [an asyncronous version of the same code](https://github.com/athenaeum-brew/concurrent-examples/blob/main/Example04AsyncWithLatches.java) that produce an ordered output, using [latches](https://www.baeldung.com/java-countdown-latch).

---

# Concurrency - Lesson

Lesson learned: 

**An (incorrect) asynchronous, parallel, concurrent, or multithreaded program may produce the expected results for a loooong time before crashing unexpectedly.**

---

# Concurrency - Testing

<!-- Although testing is explicitly out of the scope of this course, I cannot help but briefly mention some guidelines for testing asynchronous, parallel, concurrent, or multithreaded programs. -->

<small>

1. **Unit Testing**: Use mocking frameworks (like [Mockito](https://site.mockito.org/)) to simulate asynchronous behavior and test individual components in isolation.

--

1. **Thread Contention Testing**: Use tools like [Apache JMeter](https://jmeter.apache.org/) or [Gatling](https://gatling.io/) to simulate high load and thread contention.

--

1. **Race Condition Detection**: Use static analysis tools like [SonarQube](https://www.sonarsource.com/products/sonarqube) to detect potential race conditions in your code.
Employ dynamic analysis tools like [ThreadSanitizer](https://openjdk.org/jeps/8208520) (work in progress) or tools integrated in IDEs (like IntelliJ IDEAâ€™s concurrency analysis features).

--

1. **Code Reviews**: Conduct thorough code reviews with a focus on concurrency issues.
Have multiple team members review the code to identify potential pitfalls in thread management and synchronization.

--

1. **Logging and Monitoring**: Implement extensive logging to trace the behavior of threads and asynchronous operations.
Use monitoring tools to observe the system in real-time and post-mortem analysis to identify the causes of crashes.

--

1. **Use of Concurrent Collections and Utilities**: Prefer using thread-safe collections and utilities provided by the Java java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, and ExecutorService.

</small>

---

# Concurrency - Live Examples 2

Introducing [TheBumper](https://github.com/athenaeum-brew/concurrent-examples/blob/main/TheBumper.java) class.

```java
public final class TheBumper {
    private final String title = "\nA programmer had a problem. He thought to himself, \"I know, I'll solve it with threads!\".\n";
    private final String[] array = new String[] { "Now,", "he", "has", "two", "problems." };
    private int count = 0;

    public final String next() {
        return array[increment()];
    }

    private final int increment() {
        return count++;
    }

    public final int length() {
        return array.length;
    }

    public final String title() {
        return title;
    }
}
```

---

# Concurrency - Live Examples 2

Synchronous Bumper

```java
public class Example10BumperSync {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            System.out.println(bumper.next());
        }
    }
}
```

Output:

```bash
% java Example10BumperSync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[main] Now, 
[main] he 
[main] has 
[main] two 
[main] problems. 
```

---

# Concurrency - Live Examples 2

Asynchronous Bumper

```java
public class Example11BumperAsync {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                System.out.println(bumper.next());
            });
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
            ; // Wait for all threads to finish
        }
    }
}
```

Output:

```bash
% java Example11BumperAsync.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-2] he 
[pool-1-thread-1] Now, 
[pool-1-thread-5] problems. 
[pool-1-thread-4] two 
[pool-1-thread-3] has 
```

---

# Concurrency

The **Synchronized** Keyword in Java

<small>

*Ensures that only one thread can access a critical section of code at a time.*

--

Applied to methods or code blocks. 

</small>

<div style="display: flex;">
<div style="flex: 1; margin-right:1rem;">
<pre><code class="language-java">public synchronized void synchronizedMethod() {
    // Critical section of code
    // Only one thread can execute this method at a time
}</code></pre>
</div>
<div style="flex: 1; margin-left:1rem;">
<pre><code class="language-java">// Object used for synchronization
private static final Object lock = new Object(); 
public void doSomethingSynchronized() {
    synchronized (lock) {
        // Critical section of code
        // Only one thread can execute this block at a time
    }
}
</code></pre>
</div>
</div>

<small>

--

**Advantages**:
Simplifies multithreading by handling synchronization internally.
Prevents concurrent modification of shared resources, which is a common cause of race conditions.

--

**Disadvantages**:
Can cause performance overhead due to locking.
May lead to potential deadlocks if not used cautiously.

--

**Best Practices**:
Use synchronized blocks for finer-grained control.
Consider alternatives like java.util.concurrent for more advanced synchronization needs.

</small>

---

# Concurrency - Live Examples 2

Synchronized Asynchronous Bumper

```java
public class Example12BumperSynchronized {
    public static void main(String[] args) {
        TheBumper bumper = new TheBumper();
        ExecutorService executor = Executors.newFixedThreadPool(bumper.length());
        System.out.println(bumper.title());
        for (int i = 0; i < bumper.length(); i++) {
            executor.execute(() -> {
                synchronized (bumper) {
                    System.out.println(bumper.next());
                }
            });
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
            ; // Wait for all threads to finish
        }
    }
}
```

Output:

```bash
% java Example12BumperSynchronized.java

A programmer had a problem. He thought to himself, "I know, I'll solve it with threads!".

[pool-1-thread-1] Now, 
[pool-1-thread-5] he 
[pool-1-thread-4] has 
[pool-1-thread-3] two 
[pool-1-thread-2] problems. 
```

